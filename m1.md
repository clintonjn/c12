# React Native Environment Setup Guide

## Overview

This guide explains how to set up multiple environments (dev, staging, preprod, production) in React Native using react-native-dotenv and Expo prebuild.

## Problem Statement

- Need separate configurations for different deployment stages
- Want to install multiple app versions simultaneously on device
- Avoid Metro cache issues when switching environments
- Prevent git conflicts with generated native code

## Solution Architecture

Uses Expo's app config system with environment variables to generate different native projects for each environment, rather than manual Android flavors or iOS schemes that get overwritten by prebuild.

## Environment Configuration

### 1. Environment Files

```
.env.dev              # Development environment
.env.staging          # Staging environment
.env.preproduction    # Pre-production environment
.env.production       # Production environment
```

Each file contains:

```
IS_PRODUCTION=false
ENVIRONMENT=dev
API_BASE_URL=https://api.dev.c12app.com
APP_NAME="C12 Dev"
```

### 2. Dependencies

```bash
npm install react-native-dotenv @types/react-native-dotenv --save-dev
npm install babel-preset-expo --save-dev
```

### 3. Babel Configuration

`babel.config.js`:

```js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module:react-native-dotenv',
        {
          envName: 'APP_ENV',
          moduleName: '@env',
          path: '.env',
        },
      ],
    ],
  };
};
```

### 4. App Configuration

`app.config.js` - Generates different app names and package IDs:

```js
const ENV = process.env.ENVIRONMENT;

const getAppName = () => {
  switch (ENV) {
    case 'dev':
      return 'C12 Dev';
    case 'staging':
      return 'C12 Staging';
    case 'preproduction':
      return 'C12 PreProd';
    case 'production':
      return 'C12';
    default:
      return 'C12 Dev';
  }
};

const getPackageId = () => {
  switch (ENV) {
    case 'dev':
      return 'com.c12.dev';
    case 'staging':
      return 'com.c12.staging';
    case 'preproduction':
      return 'com.c12.preprod';
    case 'production':
      return 'com.c12';
    default:
      return 'com.c12.dev';
  }
};

export default {
  expo: {
    name: getAppName(),
    slug: 'c12',
    version: '1.0.0',
    android: {
      package: getPackageId(),
      adaptiveIcon: {
        backgroundColor: getIconColor(),
      },
    },
    ios: {
      bundleIdentifier: getPackageId(),
    },
  },
};
```

### 5. Build Scripts

`package.json` scripts for each environment:

```json
{
  "scripts": {
    "prebuild:dev": "ENVIRONMENT=dev expo prebuild --clean",
    "prebuild:staging": "ENVIRONMENT=staging expo prebuild --clean",
    "prebuild:preprod": "ENVIRONMENT=preproduction expo prebuild --clean",
    "prebuild:prod": "ENVIRONMENT=production expo prebuild --clean",
    "run:dev": "ENVIRONMENT=dev expo run:android",
    "run:staging": "ENVIRONMENT=staging expo run:android",
    "run:preprod": "ENVIRONMENT=preproduction expo run:android",
    "run:prod": "ENVIRONMENT=production expo run:android"
  }
}
```

## Git Configuration

### .gitignore Setup

```
# Generated native folders (expo prebuild)
android/
ios/
```

**Why exclude native folders:**

- Generated by `expo prebuild` from app config
- Prevents merge conflicts on generated code
- Each developer generates their own native folders
- Ensures consistent builds across team

## Usage Workflow

### Daily Development

```bash
# Setup environment (first time or when switching)
npm run prebuild:dev

# Build and run
npm run run:dev
```

### Environment Switching

```bash
# Switch to staging
npm run prebuild:staging
npm run run:staging

# Switch to production
npm run prebuild:prod
npm run run:prod
```

### Team Onboarding

```bash
git clone <repo>
npm install
npm run prebuild:dev    # Generates android/ios folders
npm run run:dev
```

## Key Benefits

1. **Simultaneous Installation**: All 4 apps can be installed on same device
2. **Clear Identification**: Different app names and icon colors
3. **No Cache Issues**: `--clean` flag prevents Metro cache problems
4. **Team Consistency**: Generated folders ensure same build for everyone
5. **No Manual Native Config**: Everything through Expo app config

## Environment Results

| Environment | App Name    | Package ID      | Icon Color |
| ----------- | ----------- | --------------- | ---------- |
| Dev         | C12 Dev     | com.c12.dev     | Orange     |
| Staging     | C12 Staging | com.c12.staging | Teal       |
| PreProd     | C12 PreProd | com.c12.preprod | Blue       |
| Production  | C12         | com.c12         | White      |

## Troubleshooting

### Metro Cache Issues

If environment variables seem stale:

```bash
npx expo start --clear
```

### Missing babel-preset-expo

```bash
npm install babel-preset-expo --save-dev
```

### App Shows "Expo Go" Name

You're running in development mode. Use `expo run:android` instead of `expo start` to see actual app names.

## Technical Reasoning

**Why Expo app config over manual flavors:**

- Expo prebuild overwrites manual Android/iOS configurations
- App config ensures consistency across prebuilds
- Environment variables baked in at build time
- Prevents configuration drift between environments

**Why separate package IDs:**

- Allows multiple environment apps on same device
- Clear separation in app stores
- Different signing certificates per environment
- Independent app data and permissions

## Icon Configuration

### Current Setup: Same Icon with Different Backgrounds

The project uses a single icon (`mobile-development.png`) with different background colors for each environment:

- **Dev**: Orange background (#ff6b35)
- **Staging**: Teal background (#4ecdc4)
- **PreProd**: Purple background (#d145beff)
- **Production**: White background (#ffffff)

### Alternative: Different Icons Per Environment

To use completely different icons for each environment:

1. **Create 4 icon files** (1024x1024 PNG) in `assets/` directory:
   - `icon-dev.png` - Development icon
   - `icon-staging.png` - Staging icon
   - `icon-preprod.png` - Pre-production icon
   - `icon-prod.png` - Production icon

2. **Update app.config.js**:
   - Uncomment the `getIcon()` function
   - Replace `icon: './assets/mobile-development.png'` with `icon: getIcon()`
   - Replace adaptive icon settings with `icon: getIcon()`

### Icon Creation Options:

**Option 1: Online Icon Generator**

- Use https://icon.kitchen or similar tools
- Create 4 versions with different themes/colors
- Download as 1024x1024 PNG

**Option 2: Design Tools**

- Use Figma, Canva, or Photoshop
- Create base design with environment-specific variations
- Export as PNG 1024x1024

**Option 3: Command Line (ImageMagick)**

```bash
# Create simple colored icons
convert -size 1024x1024 xc:"#ff6b35" assets/icon-dev.png
convert -size 1024x1024 xc:"#4ecdc4" assets/icon-staging.png
convert -size 1024x1024 xc:"#45b7d1" assets/icon-preprod.png
convert -size 1024x1024 xc:"#ffffff" assets/icon-prod.png
```

## ESLint and Prettier Setup

### Overview

This section covers setting up code linting and formatting for the React Native TypeScript project using ESLint and Prettier.

### Why ESLint 8 Instead of ESLint 9?

**ESLint 9 Limitations with React Native:**

- Uses new flat config format (`eslint.config.js`)
- `@react-native/eslint-config` not yet compatible with flat config
- Most React Native plugins still expect legacy `.eslintrc.js` format
- Expo tooling and Metro bundler integration uses old format
- Peer dependency conflicts with RN ecosystem packages

**Current Best Practice (2024/2025):**
Use ESLint 8 with legacy config for maximum React Native ecosystem compatibility until the ecosystem migrates to ESLint 9.

### Required Dependencies

```bash
npm install --save-dev eslint@8 @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-plugin-react-native prettier eslint-config-prettier eslint-plugin-ft-flow
```

**Package Breakdown:**

- `eslint@8` - Core linting engine (v8 for RN compatibility)
- `@typescript-eslint/parser` - TypeScript parser for ESLint
- `@typescript-eslint/eslint-plugin` - TypeScript-specific linting rules
- `eslint-plugin-react` - React-specific linting rules
- `eslint-plugin-react-native` - React Native-specific linting rules
- `prettier` - Code formatter
- `eslint-config-prettier` - Disables ESLint rules that conflict with Prettier
- `eslint-plugin-ft-flow` - Required by @react-native/eslint-config
- `@react-native/eslint-config` - Official React Native ESLint configuration

### Configuration Files

#### ESLint Configuration (`.eslintrc.js`)

```js
module.exports = {
  root: true,
  extends: ['@react-native', 'prettier'],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'react-native'],
  rules: {
    // React Native specific rules
    'react-native/no-unused-styles': 'error',
    'react-native/no-inline-styles': 'warn',

    // TypeScript rules
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',

    // General rules
    'no-console': 'warn',
    'prefer-const': 'error',
  },
  env: {
    'react-native/react-native': true,
  },
};
```

#### Prettier Configuration (`.prettierrc`)

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### Package.json Scripts

Add these scripts to your `package.json`:

```json
{
  "scripts": {
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,ts,tsx,json,md}\""
  }
}
```

### Usage Commands

```bash
# Check for linting errors
npm run lint

# Auto-fix linting errors
npm run lint:fix

# Format code with Prettier
npm run format

# Check formatting without fixing
npm run format:check
```

### VS Code Integration

Install these VS Code extensions:

- **ESLint** - Provides real-time linting in editor
- **Prettier - Code formatter** - Provides formatting on save

Add to VS Code settings (`.vscode/settings.json`):

```json
{
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
}
```

### Linting Rules Explained

**React Native Rules:**

- `react-native/no-unused-styles` - Prevents unused StyleSheet definitions
- `react-native/no-inline-styles` - Warns against inline styles (performance)

**TypeScript Rules:**

- `@typescript-eslint/no-unused-vars` - Catches unused variables
- `@typescript-eslint/no-explicit-any` - Warns against using `any` type

**General Rules:**

- `no-console` - Warns about console.log statements
- `prefer-const` - Enforces const for variables that aren't reassigned

### Benefits

1. **Code Quality**: Catches errors before runtime
2. **Consistency**: Enforces consistent coding style across team
3. **React Native Specific**: Catches RN-specific anti-patterns
4. **TypeScript Integration**: Proper TypeScript linting support
5. **Auto-fixing**: Many issues can be automatically resolved
6. **Editor Integration**: Real-time feedback in VS Code

### Migration to ESLint 9 (Future)

When the React Native ecosystem supports ESLint 9:

1. Upgrade to `eslint@9`
2. Convert `.eslintrc.js` to `eslint.config.js` (flat config)
3. Update plugin configurations for flat config format
4. Test thoroughly with React Native tooling

Until then, ESLint 8 provides the most stable and compatible linting experience for React Native projects.

### Pre-commit Hooks Setup

#### Overview

Pre-commit hooks automatically run linting and formatting before each commit, ensuring code quality and consistency across the team.

#### Required Dependencies

```bash
npm install --save-dev husky lint-staged
```

**Package Breakdown:**

- `husky` - Git hooks manager that runs scripts on git events
- `lint-staged` - Runs linters only on staged files (faster than full project)

#### Setup Steps

**1. Initialize Husky:**

```bash
npx husky init
```

**2. Configure Pre-commit Hook:**
Update `.husky/pre-commit` file:

```bash
npx lint-staged
```

**3. Add lint-staged Configuration:**
Add to `package.json`:

```json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"],
    "*.{json,md}": ["prettier --write"]
  }
}
```

#### How It Works

**Commit Process:**

```bash
git add .
git commit -m "feat: add new component"
```

**Automatic Execution:**

1. **Husky triggers** → `.husky/pre-commit` runs
2. **lint-staged executes** → Only on staged files
3. **For JS/TS files:**
   - Runs `eslint --fix` (fixes linting issues)
   - Runs `prettier --write` (formats code)
4. **For JSON/MD files:**
   - Runs `prettier --write` (formats code)
5. **If successful** → Commit proceeds
6. **If errors** → Commit blocked, must fix issues

#### Example Workflow

**Before (your code):**

```js
const x = 1;
console.log(x);
```

**After pre-commit hook:**

```js
const x = 1;
console.log(x);
```

#### Benefits

**1. Automatic Quality Control**

- Prevents bad code from being committed
- Consistent formatting across entire team
- Catches errors before they reach repository

**2. Performance Optimization**

- Only processes staged files (not entire codebase)
- Fast execution on commits
- No waiting for full project linting

**3. Team Consistency**

- Everyone's commits automatically formatted
- No manual "fix formatting" commits needed
- Enforces coding standards automatically

**4. Developer Experience**

- No need to remember to run linters manually
- Immediate feedback on code quality issues
- Seamless integration with existing workflow

#### Troubleshooting

**Hook not running:**

```bash
# Ensure hooks are executable
chmod +x .husky/pre-commit

# Reinstall husky
npm run prepare
```

**Bypass hook (emergency only):**

```bash
git commit -m "emergency fix" --no-verify
```

**Check what files will be processed:**

```bash
npx lint-staged --dry-run
```

#### File Structure

After setup, your project will have:

```
.husky/
├── _/
└── pre-commit          # Pre-commit hook script

package.json            # Contains lint-staged config
```

This setup ensures every commit maintains high code quality and consistent formatting automatically.

## Registration Page Implementation

### Overview

Implementation of a complete user registration flow with form validation, Google sign-in option, and navigation between screens.

### Component Structure

**Registration Component** (`src/components/Registration.tsx`)

- Form fields: First Name, Last Name, Phone Number, Email Address
- App logo placeholder (C12)
- Form validation with all fields required
- Google registration option
- Clean UI using Ubuntu Mono fonts

**Welcome Component** (`src/components/Welcome.tsx`)

- Welcome message with C12 branding
- Uses GruppoRegular font for C12 title
- Success screen after registration

### App Navigation Flow

**State Management:**

```js
const [showSplash, setShowSplash] = useState(true);
const [isRegistered, setIsRegistered] = useState(false);
```

**Flow Sequence:**

1. **Splash Screen** → Initial loading
2. **Registration Screen** → User form input
3. **Welcome Screen** → Registration success

### Form Implementation

**Form State:**

```js
const [formData, setFormData] = useState({
  firstName: '',
  lastName: '',
  phoneNumber: '',
  email: '',
});
```

**Form Validation:**

```js
const handleRegister = () => {
  if (
    formData.firstName &&
    formData.lastName &&
    formData.phoneNumber &&
    formData.email
  ) {
    onRegistrationComplete();
  } else {
    // Show error for incomplete form
  }
};
```

### Key Features

**Registration Options:**

- Manual registration with form validation
- Google Sign-In button (ready for integration)
- Both paths navigate to Welcome screen

**User Experience:**

- ScrollView for keyboard handling
- Proper input types (phone-pad, email-address)
- Consistent Ubuntu Mono typography
- Clean, professional styling

**Form Validation:**

- All fields required before submission
- Basic validation logic implemented
- Ready for enhanced validation (email format, etc.)

### Styling Approach

**Design System:**

- Background: Light gray (`#f5f5f5`)
- Input fields: White with subtle borders
- Buttons: Dark theme with clear hierarchy
- Typography: Ubuntu Mono for consistency

**Responsive Design:**

- Mobile-first approach
- Proper spacing and padding
- Center-aligned content
- Keyboard-friendly layout

### Future Enhancement Ready

**Google Sign-In Integration:**

- Component structure ready for `@react-native-google-signin/google-signin`
- Placeholder function prepared for actual implementation

**Advanced Validation:**

- Email format validation
- Phone number formatting
- Real-time field validation
- Error message display

This implementation provides a solid foundation for user onboarding with clean code structure and room for future enhancements.
